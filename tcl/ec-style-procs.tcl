ad_library {
    Establishing site-wide style conventions and supporting documentation.
    
    @author Phillip Greenspun [philg@arsdigita.colm]
    @creation-date June 30, 1999
    @cvs-id ad-style.tcl,v 3.7.2.5 2000/09/22 01:33:58 kevin Exp
    @author ported by Jerry Asher (jerry@theashergroup.com)
}

proc_doc ec_register_styletag {
    tagname tag_documentation proc_body
} {

    Defines a new site-wide style, includes an ADP tag and a procedure
    for use by .tcl pages (starting with "ec_style_").  The supplied
    procedure body should reference $string and $tagset (the variables
    given in the AOLserver Tcl API docs for ns_register_adptag)

} {
    ns_share ec_styletag
    ns_share ec_styletag_source_file
    set generated_proc_name "ec_style_$tagname"
    proc_doc $generated_proc_name  {{string ""} {tagset ""}} "Proc generated by ec_register_styletag to support the $tagname ADP tag." $proc_body
    # let's register the ADP tag now
    ns_register_adptag $tagname "/$tagname" $generated_proc_name
    set ec_styletag($tagname) $tag_documentation
    set ec_styletag_source_file($tagname) [info script]
}

proc ec_style_template_root_internal {} {
    set templateroot [util_memoize {ad_parameter -package_id [ec_id] TemplateRoot "style"} [ec_cache_refresh]]
    if {[empty_string_p $templateroot]} {
        return [ec_url_concat [ec_pageroot] templates]
    } 
    if {[string equal [string range $templateroot 0 2] ../]} {
        return [file join [ns_info pageroot] [string range $templateroot 3 end]]
    } elseif {[string equal [string range $templateroot 0 0] /]} {
        return [file join [ns_info pageroot] [string range $templateroot 1 end]]
    } else {
        return [file join [ec_pageroot] $templateroot]
    }
}

proc ec_style_template_root {} {
    return [util_memoize {ec_style_template_root_internal} [ec_cache_refresh]]
}

# per /doc/style.html we standardize on "language_preference"
# and "prefer_text_only_p" as the names of the cookies
proc ec_style_language_from_cookie {} {
    set headers [ns_conn headers]
    set cookie [ns_set get $headers Cookie]
    if { [regexp {language_preference=([^;]+)} $cookie {} language_preference] } {
	return $language_preference
    } else {
	return ""
    }
}

proc ec_style_plain_fancy_from_cookie {} {
    set headers [ns_conn headers]
    set cookie [ns_set get $headers Cookie]
    if { [regexp {prefer_text_only_p=([^;]+)} $cookie {} prefer_text_only_p] } {
	if { $prefer_text_only_p == "t" } {
	    return "plain"
	} else {
	    return "fancy"
	}
	return $language_preference
    } else {
	return ""
    }
}

proc_doc ec_style_user_preferences_from_db {user_id} {
    Returns a list of prefer_text_only_p and language_preference from
    the user_preferences table; probably you should call this within a
    util_memoize so that you aren't kicking the stuffing out of Oracle.
} {
    if { [db_0or1row preference_select {
	select prefer_text_only_p, language_preference 
	from user_preferences 
	where user_id = :user_id
    }] } {
	set result_list [list $prefer_text_only_p $language_preference]
    } else {
	set result_list [list "" ""]
    }
    return $result_list 
}

# takes list of raw filenames and returns a list of lists
# (each sublist is score then filename)
# we give a template scores as follows:
#   2000 for having the user's preferred language
#   1000 for having the site's default language
#    200 for having the user's default plain/fanciness
#    100 for having the site's default plain/fanciness
# subtract the length of the filename so that shorter ones have precedence
# (note that language outweighs graphical fanciness)
proc ec_style_score_templates {template_filename_list} {
    # set defaults
    set user_preferred_language ""
    set user_preferred_plain_fancy ""
    set site_default_language [util_memoize {ad_parameter -package_id [ec_id] LanguageSiteDefault style} [ec_cache_refresh]]
    set site_default_plain_fancy [util_memoize {ad_parameter -package_id [ec_id] PlainFancySiteDefault style} [ec_cache_refresh]]
    # let's figure out first whether or not this is a logged-in person
    set user_id [ad_get_user_id]
    if { $user_id == 0 } {
	# not logged in, maybe cookied though
	if [util_memoize {ad_parameter -package_id [ec_id] LanguageCookieP style} [ec_cache_refresh]] {
	    # let's at least look for a cookie
	    set user_preferred_language [ec_style_language_from_cookie]
	}
	if [util_memoize {ad_parameter -package_id [ec_id] PlainFancyCookieP style} [ec_cache_refresh]] {
	    set user_preferred_plain_fancy [ec_style_plain_fancy_from_cookie]
	}
    } else {
	# this is a logged-in user, let's get this info from user_preferences
	set preferences_list [util_memoize "ec_style_user_preferences_from_db $user_id" [ec_cache_refresh]]
	set prefer_text_only_p [lindex $preferences_list 0]
	set language_preference [lindex $preferences_list 1]
	# if the text_only_p column isn't null, set user preference
	if { $prefer_text_only_p == "t" } {
	    set user_preferred_plain_fancy "plain"
	} elseif { $prefer_text_only_p == "f" } {
	    set user_preferred_plain_fancy "fancy"
	} 
	set user_preferred_language $language_preference
    }
    set result_list [list]
    foreach filename $template_filename_list {
	set score 0
	if { ![empty_string_p $user_preferred_language] && [string match "*.$user_preferred_language.*" $filename] } {
	    incr score 2000
	}
	if { ![empty_string_p $site_default_language] && [string match "*.$site_default_language.*" $filename] } {
	    incr score 1000
	}
	if { ![empty_string_p $user_preferred_plain_fancy] && [string match "*.$user_preferred_plain_fancy.*" $filename] } {
	    incr score 200
	}
	if { ![empty_string_p $site_default_plain_fancy] && [string match "*.$site_default_plain_fancy.*" $filename] } {
	    incr score 100
	}
	set score [expr $score - [string length $filename]]
	lappend result_list [list $score $filename]
    }
    return $result_list
}

proc ec_style_sort_by_score {l1 l2} {
    if { [lindex $l1 0] < [lindex $l2 0] } {
	return -1 
    } elseif { [lindex $l1 0] == [lindex $l2 0] } {
	return 0
    } else {
	return 1
    }
}

proc_doc ec_return_template {
    { file_name "" }
    { cache_p 1 }
} {

    Finds a template to source (looks at what templates are available,
what the user prefers, and what the site defaults are), parses it in
the caller's environment, and ns_return's the bytes to the
user. file_name, if specified, overrides the base file name used to
determine which template to use. cache_p, if specified, can disable or
enable caching by altering the HTTP header.

} {
    
    set full_url [ad_conn url]

    if { [string index $full_url [expr [string length $full_url]-1]] == "/" } {
	append full_url "index.tcl"
    }

    if [empty_string_p $file_name] {
	set file_name [file rootname [file tail $full_url]]
    }
    set just_the_dir [file dirname $full_url]
    set template_directory "[ec_style_template_root]$just_the_dir"

    set glob_pattern "${template_directory}/${file_name}*.adp"
    set available_templates [glob -nocomplain $glob_pattern]

    if { [llength $available_templates] == 0 } {
        # try again in the top level template directory
        set template_directory "[ec_style_template_root]"

        set glob_pattern "${template_directory}/${file_name}*.adp"
        set available_templates [glob -nocomplain $glob_pattern]
    }

    if { [llength $available_templates] == 0 } {
	ad_return_error "
        No template available" "We can't find any template for
presenting the output of this script.  Sorry but you're a victim of
our graphics ambition.  Please complain to the site owner.
        "
    } else {
	# we have at least one template available; we need to score
	# them against user's criteria, then pick the highest scorer
	set list_of_lists [ec_style_score_templates $available_templates]
	set sorted_list [lsort -decreasing -command ec_style_sort_by_score $list_of_lists]
	set top_scoring_template_filename [lindex [lindex $sorted_list 0] 1]
	set fully_qualified_template_filename "$top_scoring_template_filename"

	if { $cache_p } {
	    # build the http header, with a no cache pragma if cache_p is 0
	    set http_header "HTTP/1.0 200 OK\r
MIME-Version: 1.0\r
Content-Type: text/html\r
Pragma: No-Cache\r\n"
	    ns_write $http_header
	    ns_startcontent -type text/html
	    eval "uplevel { ns_write \"\[ns_adp_parse -file \"$fully_qualified_template_filename\"\]\" }"
	} else {
	    eval "uplevel { doc_return  200 text/html \[ns_adp_parse -file \"$fully_qualified_template_filename\"\] }"
	}
    }
}

# sample style tag
# You will get an error if you try to register
# a style tag more than once.  

ec_register_styletag footer "Standard ArsDigita footer." {
    global sidegraphic_displayed_p
    set signatory $string
    if [empty_string_p $signatory] {
	set signatory [ad_system_owner]
    } 
    if { [info exists sidegraphic_displayed_p] && $sidegraphic_displayed_p } {
	# we put in a BR CLEAR=RIGHT so that the signature will clear any side graphic
	# from the ad-sidegraphic.tcl package
	set extra_br "<br clear=right>"
    } else {
	set extra_br ""
    }
    return "
$extra_br
<hr>
<a href=\"mailto:$signatory\"><address>$signatory</address></a>
"
}

# the following style will be available in ADP pages as <BODYNOTE>
# and in Tcl pages as [ec_style_bodynote "what you want to note"]
#
# RDH: moved from photonet-styles.tcl (2000-05-30)

ec_register_styletag bodynote "A note that goes inline on a page; generally presented smaller and in a sans serif font." {
    return "<blockquote>
<font size=-2 face=\"verdana, arial, helvetica\">
$string
</font>
</blockquote>
"
}
